# -*- coding: utf-8 -*-
"""progetx.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SfWPFsI4UPVGGAuCPCVUQRnVCXR2VoOg
"""

import pandas as pd
import numpy as np
from google.colab import drive
from google.colab import files

# mount google drive
drive.mount('/content/drive', force_remount=True)

# Read loans lenders file
loans_lenders = pd.read_csv("/content/drive/My Drive/python/kiva/loans_lenders.csv")
loans_lenders.head()

"""1) Normalize the loan_lenders table. In the normalized table, each row must have one loan_id and one lender."""

# Each row is converted from string to list
loans_lenders['lenders'] = loans_lenders['lenders'].apply(lambda x:x.replace(',','').split())
# The explode function allows to transform each element of a list-like to a row, replicating index values by loan_columns
loans_lenders_splitted = loans_lenders.explode('lenders').reset_index(drop=True)
loans_lenders_splitted.head(10)

"""2) For each loan, add a column duration corresponding to the number of days between the disburse time and the planned expiration time. If any of those two dates is missing, also the duration must be missing"""

# Read loans file
loans = pd.read_csv("/content/drive/My Drive/python/kiva/loans.csv")
# Transform 'planned_expiration_time' and 'disburse_time' in pandas datetime format
loans['planned_expiration_time']=pd.to_datetime(loans['planned_expiration_time']).dt.date
loans['disburse_time']=pd.to_datetime(loans['disburse_time']).dt.date
# Create column 'duration'
loans['duration']=loans['planned_expiration_time'] - loans['disburse_time']
# Show columns 'duration'
loans['duration'].head()

"""3) Find the lenders that have funded at least twice"""

lenders_funded=loans_lenders_splitted.groupby('lenders')['loan_id'].count().reset_index(name = 'count_funded')
lenders_funded[lenders_funded['count_funded']>1].head()

print('The exact number about lenders that have funded at least twice is: ', len(lenders_funded[lenders_funded['count_funded']>1]))

"""4) For each country, compute how many loans have involved that country as borrowers"""

Loan_by_country=loans.groupby('country_name')['loan_id'].count().reset_index(name = 'loans_count')
Loan_by_country.head()

"""5) For each country, compute the overall amount of money borrowed"""

loan_amount_sum_by_country=loans.groupby('country_name')['loan_amount'].sum().reset_index(name='loan_amount_sum')
loan_amount_sum_by_country.head()

"""6) Like the previous point, but expressed as a percentage of the overall amount lent."""

loan_amount_sum_by_country_percentual=(loans.groupby('country_name')['loan_amount'].sum()/loans['funded_amount'].sum()*100).reset_index(name = 'loan_amount_%_over_total')
loan_amount_sum_by_country_percentual.head()

"""7) Like the three previous points, but split for each year (with respect to disburse time)"""

# Create a new column corresponding to the year of disburse_time
loans['disburse_time_year']=pd.to_datetime(loans['disburse_time']).dt.year

ES_4_for_each_year=loans.groupby(['country_name','disburse_time_year'])['loan_id'].count().reset_index(name='loan_count')
ES_4_for_each_year

ES_5_for_each_year=loans.groupby(['country_name','disburse_time_year'])['loan_amount'].sum().reset_index(name='loan_amount_sum')
ES_5_for_each_year

ES_6_for_each_year=(loans.groupby(['country_name','disburse_time_year'])['loan_amount'].sum()/loans['funded_amount'].sum()*100).reset_index(name='loan_amount_%_over_total')
ES_6_for_each_year

"""8) For each lender, compute the overall amount of money lent. For each loan that has more than one lender, you must assume that all lenders contributed the same amount"""

# For each loan, new columns have been created corresponding to the funded amount and loan amount by each lenders present in the aforementioned loan
loans['funded_amount_x_lenders']=loans['funded_amount']/loans['num_lenders_total']
loans['loan_amount_x_lenders']=loans['loan_amount']/loans['num_lenders_total']
# Merge between dataset (loans) and dataset (loand lenders splitted) 
merge=loans[['loan_id','funded_amount_x_lenders','loan_amount_x_lenders']].merge(loans_lenders_splitted)
# Compute the overall amount of money lent and the overall amount of money borrowed for each lender
merge=pd.DataFrame(merge.groupby('lenders')[['funded_amount_x_lenders','loan_amount_x_lenders']].sum())
merge.reset_index(inplace=True)
# Show the overall amount of monney lent for each lender
merge[['lenders','funded_amount_x_lenders']]

loans[['loan_id','funded_amount_x_lenders','loan_amount_x_lenders']][loans['num_lenders_total']==0].merge(loans_lenders_splitted)

"""9) For each country, compute the difference between the overall amount of money lent and the overall amount of money borrowed. Since the country of the lender is often unknown, you can assume that the true distribution among the countries is the same as the one computed from the rows where the country is known."""

# Read lenders file
lenders = pd.read_csv("/content/drive/My Drive/python/kiva/lenders.csv")
# Drop rows with Nan values in 'country code' and 'permanent name' columns and rename the column permanent name
lenders.dropna(subset=['country_code'],inplace=True)
lenders.dropna(subset=['permanent_name'],inplace=True)
lenders.rename(columns={'permanent_name':'lenders'},inplace=True)
lenders.head()

# Merge between dataset (lenders dropped) and the dataset created at the previous point 
df=merge.merge(lenders[['lenders','country_code']])
# Compute the difference between loan_amount_x_lenders and funded_amount_x_lenders for each country
diff_country=(df.groupby('country_code')['loan_amount_x_lenders'].sum()-df.groupby('country_code')['funded_amount_x_lenders'].sum()).reset_index(name='diff_between_fundedamount_and_loanamount')
diff_country

"""10) Which country has the highest ratio between the difference computed at the previous point and the population?"""

# Read file country stats
country_stats=pd.read_csv('/content/drive/My Drive/python/kiva/country_stats.csv')
# Merge between dataset created at the previous point and dataset (country_stats)
ratio_population=country_stats[['country_code','country_name','population']].merge(diff_country)
# Create a new column about ratio between the difference computed at the previous point and the population
ratio_population['ratio_diffFundedLoan_population']=ratio_population['diff_between_fundedamount_and_loanamount']/ratio_population['population']
# Show the country  with the highest ratio
ratio_population[ratio_population['ratio_diffFundedLoan_population']==ratio_population['ratio_diffFundedLoan_population'].max()]

"""11) Which country has the highest ratio between the difference computed at point 9 and the population that is not below the poverty line"""

# Drop rows with Nan values in 'population_below_poverty_line' columns and rename the column permanent name
country_stats.dropna(subset=['population_below_poverty_line'],inplace=True)
# For each country, create a new column about difference between the total amount of population and the amount of population under the poverty line
country_stats['not_poor']=country_stats['population'] - (country_stats['population_below_poverty_line']*country_stats['population']/100)

# Merge between dataset (country_stats_dropped) and dataset created at the point 9
ratio_population_rich=country_stats.merge(diff_country)
# Create a new column about ration between the difference computed at point 9 and the population that is not below the poverty line
ratio_population_rich['ratio']=ratio_population_rich['diff_between_fundedamount_and_loanamount'] /ratio_population_rich['not_poor']

ratio_population_rich[ratio_population_rich['diff_between_fundedamount_and_loanamount']==ratio_population_rich['diff_between_fundedamount_and_loanamount'].max()]

"""12) For each year, compute the total amount of loans. Each loan that has planned expiration time and disburse time in different years must have its amount distributed proportionally to the number of days in each year. For example, a loan with disburse time December 1st, 2016, planned expiration time January 30th 2018, and amount 5000USD has an amount of 5000USD * 31 / (31+365+30) = 363.85 for 2016, 5000USD * 365 / (31+365+30) = 4284.04 for 2017, and 5000USD * 30 / (31+365+30) = 352.11 for 2018."""

# Create a new column about the year of planned expiration time
loans['planned_expiration_time_year']=pd.to_datetime(loans['planned_expiration_time']).dt.year
# Drop rows with missing values in 'planned_expiration_time_year' column and 'disburse_time_year' column
loans.dropna(subset=['planned_expiration_time_year'],inplace=True)
loans.dropna(subset=['disburse_time_year'],inplace=True)
# Remove rows where the year of disburse time is > than the year of planned expiration time
loans=loans[loans['disburse_time_year']<=loans['planned_expiration_time_year']]

loans['days_in_disburse_time_year']=365
loans['days_in_planned_expiration_time_year']=365
loans.loc[loans['disburse_time_year'] == 2014, 'days_in_disburse_time_year'] = 366
loans.loc[loans['planned_expiration_time'] == 2014, 'days_in_planned_expiration_time_year'] = 366

# Created a new column with the number of days to be attributed to the first year
loans['days_disburse_time_year']= loans['days_in_disburse_time_year']- pd.to_datetime(loans['disburse_time']).dt.dayofyear
# Created a new column about the number of days of the relative year of planned expiration time
loans['days_planned_expiration_time_year']=pd.to_datetime(loans['planned_expiration_time']).dt.dayofyear
# Created a new column computing the difference in year between planned expiration time and disburse time
loans['difference_years']=loans['planned_expiration_time_year']-loans['disburse_time_year']

# Created new columns for each year of our interest
bound = range(int(loans['disburse_time_year'].min()),int(loans['planned_expiration_time_year'].max())+1)
for i in bound:
    loans[str(i)] = 0

# Selected only columns we need
atribute = ['loan_amount', '2011', '2012', '2013', '2014','2015', '2016', 
            '2017', '2018', 'difference_years', 'days_disburse_time_year',
            'days_planned_expiration_time_year', 'disburse_time_year', 'planned_expiration_time_year', 'days_in_disburse_time_year','days_in_planned_expiration_time_year']
loans = loans[atribute]
loans.head()

loans['difference_years'].unique()

# Create function 
def loan(x):
    if x['difference_years'] == 0: # se disburse e planned hanno stipulazione e scadenza nello stesso anno.
        x[str(int(x['disburse_time_year']))]= x['loan_amount'] # l'intero ammontare di loan_amount viene inserito 
                                                       # nella colonna in corrispondenza del medesimo anno.
    elif x['difference_years']== 1:
        x[str(int(x['disburse_time_year']))]= (x['days_disburse_time_year']*x['loan_amount'])/((x['days_disburse_time_year'])+ x['days_planned_expiration_time_year']+ ((x['difference_years']-1)*int(x['days_in_disburse_time_year'])))
        x[str(int(x['planned_expiration_time_year']))]= x['loan_amount'] - x[str(int(x['disburse_time_year']))]
        
    elif x['difference_years'] > 1:
        x[str(int(x['disburse_time_year']))]= x['days_disburse_time_year']*x['loan_amount'] / (x['days_disburse_time_year'] + x['days_planned_expiration_time_year'] + ((x['difference_years']-1)*int(x['days_in_disburse_time_year'])))
        x[str(int(x['planned_expiration_time_year']))]=(x['days_planned_expiration_time_year']*x['loan_amount'])/((x['days_disburse_time_year'])+ x['days_planned_expiration_time_year']+ ((x['difference_years']-1)* int(x['days_in_planned_expiration_time_year'])))
        
        for y in range(1,int(x['difference_years'])):
          if (int(x['disburse_time_year']+y) == 2014) :
            x[str(int(x['disburse_time_year']+y))] = (366*x['loan_amount'])/((x['days_disburse_time_year'])+ x['days_planned_expiration_time_year']+ ((x['difference_years']-1)*366))
          else :
            x[str(int(x['disburse_time_year']+y))] = (365*x['loan_amount'])/((x['days_disburse_time_year'])+ x['days_planned_expiration_time_year']+ ((x['difference_years']-1)*365))

    return x

# Apply function
df1 = loans.apply(loan,axis=1)
df1.head()

# Show result
loan_amount_by_years = [(lambda x: str(x))(x) for x in list(bound)] 
df1[loan_amount_by_years].apply(lambda x: int(x.sum())).reset_index().rename(columns={'index':'year',0:'total'})

